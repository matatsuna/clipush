	#packopt name"通信速度Viewer2.0"
	#include "user32.as"
	#enum IDM_ITEM1 = 1

	#module ;// 変数の任意の位置から文字列を読む
	#defcfunc peekstr var a, int ofs
	dupptr tmpstr,varptr(a)+ofs,1,2:return tmpstr
	#global

	;// IP Helper の準備
	#uselib "iphlpapi.dll" ;// IP HelperのAPI定義
	#func GetIfTableSz "GetIfTable" nullptr,var,nullptr
	#func GetIfTable "GetIfTable" var,var,nullptr

	; ウィンドウを移動可能にする
	#define WM_NCLBUTTONDOWN $000000A1
	#define HTCAPTION 2

	#define ctype EntryIdx(%1,%2) ((%1)*215+1+(%2)) ;// おまけ

	#define WS_EX_TOOLWINDOW	0x00000080 //ツールウィンドウを作成します


	bgscr 0,190,30,2 //枠分を余分に確保
	GetWindowLong hwnd,-20
	SetWindowLong hwnd,-20,stat  |WS_EX_TOOLWINDOW//|WS_EX_DLGMODALFRAME
	width 190,30  //ウィンドウを再描画させる（SetWindowPosの代用）
	//+6して描画領域を640,480にしてる

	GetIfTableSz tablesize ;// 必要なサイズを調べる
	dim mib_iftable, tablesize+3>>2 ;// 確保する。
	GetIfTable mib_iftable, tablesize ;// 取得する。

	list = ""
	repeat mib_iftable ;// 取得したエントリの数が入っている
	    list += ""+cnt+" "+peekstr(mib_iftable , EntryIdx(cnt,151) *4) + "\n"
	loop

;	<メインのポップアップメニュー>
;	メインのポップアップメニューを作成し、ハンドルを取得
	CreatePopupMenu
	hMenu.1 = stat
	AppendMenu hMenu.1, 0, IDM_ITEM1, "閉じる"

	gsel 0,2

	notesel txt
	chdir dir_exe
	exist"config"
	if strsize!-1{
		noteload"config"
		noteget winx,0
		winx=int(winx)
		noteget winy,1
		winy=int(winy)
		}else{
		winx=0
		winy=0
		noteadd ""+winx+"",0,1
		noteadd ""+winy+"",1,1
		notesave "config"
}

	//bgscr 0,190,30,12,winx,winy
	width ,,winx,winy
	//gsel 0,2
	font"",15
	
	onexit goto*e
	onclick gosub*WindowMove

	#define PDH_FMT_LONG         ( 0x00000100)
	#define PDH_FMT_DOUBLE       ( 0x00000200)
	#define PDH_FMT_LARGE        ( 0x00000400)

	#uselib "pdh.dll"
	#cfunc PdhOpenQuery "PdhOpenQuery" int,int,int
	#cfunc PdhAddCounter "PdhAddCounterA" int,int,int,int
	#cfunc PdhCollectQueryData "PdhCollectQueryData" int
	#cfunc PdhCloseQuery "PdhCloseQuery" int
	#cfunc PdhGetFormattedCounterValue "PdhGetFormattedCounterValue" int,int,int,int

	alloc Value, 16
	dupptr cpu_l,varptr(Value)+8,4,vartype("int")
	dupptr cpu_d,varptr(Value)+8,8,vartype("double")

	hQuery=0
	hCounter=0
	mes PdhOpenQuery(NULL,0,varptr(hQuery))
	PATH="\\Processor(_Total)\\% Processor Time"
	mes PdhAddCounter( hQuery , varptr(PATH) , 0, varptr(hCounter) )
	mes PdhCollectQueryData(hQuery)

*lp
	GetIfTable mib_iftable, tablesize ;// 取得する。

	SendBytes=0
	RecvBytes=0

	repeat mib_iftable
		SendBytes += mib_iftable( EntryIdx(cnt, 144) ) ;// 144とかの数字は↓のリストを参照。
		RecvBytes += mib_iftable( EntryIdx(cnt, 138) ) 
	loop

	localsend=abs(SendBytes-prevSendBytes)

	if localsend>1024{//0
		if abs(localsend/1024)>1024{//1
			localsend=absf(localsend/1024)//1
			if abs(localsend/1024)>1024{//2
				localsend=absf(localsend/1024)//2
				if abs(localsend/1024)>1024{//3
					localsend=absf(localsend/1024)//3
				}else:localsend=""+abs(localsend/1024.0)+"G"//3
			}else:localsend=""+abs(localsend/1024.0)+"M"//2
		}else:localsend=""+abs(localsend/1024.0)+"K"//1
	}//0
	localsend=str(localsend)
	
	localrecv=abs(RecvBytes-prevRecvBytes)
	
	if localrecv>1024{//0
	
		if abs(localrecv/1024)>1024{//1
		
			localrecv=absf(localrecv/1024)//1
			if abs(localrecv/1024)>1024{//2
			
				localrecv=absf(localrecv/1024)//2
				if abs(localrecv/1024)>1024{//3
				
					localrecv=absf(localrecv/1024)//3
				}else:localrecv=""+abs(localrecv/1024.0)+"G"//3
			}else:localrecv=""+abs(localrecv/1024.0)+"M"//2
		}else:localrecv=""+abs(localrecv/1024.0)+"K"//1
	}//0
	localrecv=str(localrecv)
	
	redraw 0
	color 100,100,100 : boxf
	color 0,0,0
	
	A=PdhCollectQueryData(hQuery)
	A=PdhGetFormattedCounterValue (hCounter, PDH_FMT_DOUBLE, 0, varptr(Value))
	font"",15
	pos 0,0
	color 200,50,50
	boxf 0,0,cpu_d,15
	color 200,200,200
	mes "CPU"+int(cpu_d)+"%"

	color 0,14,224
	memory=sysinfo(33)
	boxf 0,15,memory,30
	pos 0,15
	color 200,200,200
	mes "メモリ"+sysinfo(33)+"%"

	pos 100,0
	color 235,110,159
	mes "↑"
	pos 110,0
	tmp=instr(localsend,0,"M")
	if tmp!-1:color 235,110,159:else:color 200,200,200
	mes ""+(localsend)+"Byte/s"
	
	pos 100,15
	color 0,174,224
	mes "↓"
	pos 110,15
	tmp=instr(localrecv,0,"M")
	if tmp!-1:color 0,174,224:else:color 200,200,200
	mes""+(localrecv)+"Byte/s"
	redraw 1

	prevSendBytes = SendBytes
	prevRecvBytes = RecvBytes
	await 1000			
goto *lp



*e
	mes PdhCloseQuery(hQuery)
	;	どこのウィンドウにも張り付いていないメニューは明示的に破棄
	DestroyMenu hMenu.1

*savef
	chdir dir_exe
	winx=ginfo(4)
	winy=ginfo(5)
	noteadd ""+winx+"",0,1
	noteadd ""+winy+"",1,1
	notesave "config"

end

*WindowMove
if wparam == 1 {
sendmsg hwnd,WM_NCLBUTTONDOWN,HTCAPTION,0
}

;	右クリックされた時
	if wparam = 2 {
;		ポップアップメニュー表示。第1パラに開くメニューのハンドル
		TrackPopupMenu hMenu.1, $100, ginfo(0), ginfo(1), 0, hwnd, 0
		if stat = 1 : goto*e	; 選択キャンセル
	}
goto*lp

/* EntryIdx な番号リスト
typedef struct _MIB_IFROW {
0-127	WCHAR wszName[256]; 
128	DWORD dwIndex; 
129	DWORD dwType; 
130	DWORD dwMtu; ← MTU
131	DWORD dwSpeed; ← 接続速度(bps)
132	DWORD dwPhysAddrLen; 
133-134	BYTE bPhysAddr[8]; 
135	DWORD dwAdminStatus; 
136	DWORD dwOperStatus; 
137	DWORD dwLastChange; 
138	DWORD dwInOctets; ← 総受信バイト数
139	DWORD dwInUcastPkts; 
140	DWORD dwInNUcastPkts; 
141	DWORD dwInDiscards; 
142	DWORD dwInErrors; 
143	DWORD dwInUnknownProtos; 
144	DWORD dwOutOctets; ← 総送信バイト数
145	DWORD dwOutUcastPkts; 
146	DWORD dwOutNUcastPkts; 
147	DWORD dwOutDiscards;
148	DWORD dwOutErrors;
149	DWORD dwOutQLen; 
150	DWORD dwDescrLen; 
151-214	BYTE bDescr[256]; ← インターフェースの説明
} MIB_IFROW, *PMIB_IFROW;
それ以上の細かいことは、もう一度聞くか自分で調べるある。
http://msdn.microsoft.com/library/en-us/mib/mib/mib_ifrow.asp
http://www.google.com/search?q=MIB_IFROW
*/
